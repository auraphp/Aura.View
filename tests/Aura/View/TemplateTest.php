<?php
namespace Aura\View;

use org\bovigo\vfs\vfsStream as Vfs;

/**
 * Test class for Template.
 * Generated by PHPUnit on 2011-03-27 at 14:44:16.
 */
class TemplateTest extends \PHPUnit_Framework_TestCase
{
    /**
     * Sets up the fixture, for example, opens a network connection.
     * This method is called before a test is executed.
     */
    protected function setUp()
    {
        parent::setUp();
        $this->vfs = Vfs::setup('root');
    }
    
    protected function newTemplate(array $paths = [])
    {
        $escaper_factory = new EscaperFactory;
        
        $template_finder = new TemplateFinder();
        
        $helper_locator = new HelperLocator;
        $helper_locator->set('mockHelper', function () {
            return new \Aura\View\Helper\MockHelper;
        });
        
        $template = new Template($escaper_factory, $template_finder, $helper_locator);
        $template->setPaths($paths);
        
        return $template;
    }
    
    /**
     * Tears down the fixture, for example, closes a network connection.
     * This method is called after a test is executed.
     */
    protected function tearDown()
    {
        parent::tearDown();
    }

    /**
     * @todo Implement test__get().
     */
    public function test__setGetIssetUnset()
    {
        $template = $this->newTemplate();
        $this->assertFalse(isset($template->foo));
        $template->foo = 'bar';
        $this->assertTrue(isset($template->foo));
        $this->assertSame('bar', $template->foo);
        unset($template->foo);
        $this->assertFalse(isset($template->foo));
    }
    
    public function test__call()
    {
        $template = $this->newTemplate();
        $actual = $template->mockHelper();
        $this->assertSame('Hello Helper', $actual);
    }
    
    /**
     * @todo Implement testSetData().
     */
    public function testAddSetAndGetData()
    {
        $template = $this->newTemplate();
        $expect = [];
        $actual = $template->getData();
        $this->assertSame($expect, $actual);
        
        // add data
        $template->foo = 'bar';
        $template->addData(['baz' => 'dib']);
        $expect = [
            'foo' => 'bar',
            'baz' => 'dib',
        ];
        $actual = $template->getData();
        $this->assertSame($expect, $actual);
        
        // set data
        $data = [
            'foo' => 'bar'
        ];
        $template->setData($data);
        $this->assertSame('bar', $template->foo);
        
        $actual = $template->getData();
        $this->assertSame($data, $actual);
    }
    
    /**
     * @todo Implement testFind().
     */
    public function testFind()
    {
        // prepare a set of directories and files
        $dirs = [
            Vfs::url('root' . DIRECTORY_SEPARATOR . 'foo'),
            Vfs::url('root' . DIRECTORY_SEPARATOR . 'bar'),
            Vfs::url('root' . DIRECTORY_SEPARATOR . 'baz'),
        ];
        foreach ($dirs as $dir) {
            // make dir in the vfs
            mkdir($dir, 0777, true);
            // place the same file in each dir
            $file = $dir . DIRECTORY_SEPARATOR . 'zim.php';
            file_put_contents($file, 'empty');
        }
        
        // now find it; should be the same as the one at the beginning
        // of the paths
        $template = $this->newTemplate($dirs);
        $actual = $template->find('zim');
        $expect = Vfs::url('root/foo') . DIRECTORY_SEPARATOR . 'zim.php';
        $this->assertSame($expect, $actual);
    }
    
    public function testFetch()
    {
        // the template file
        $file = 'root' . DIRECTORY_SEPARATOR
              . 'fetch' . DIRECTORY_SEPARATOR
              . 'zim.php';
        
        // convert to Vfs
        $file = Vfs::url($file);
        
        // the template code
        $code = '<?php echo $this->foo; ?>';
        
        // put it in place
        $dir = dirname($file);
        mkdir($dir, 0777, true);
        file_put_contents($file, $code);
        
        // get a template object
        $template = $this->newTemplate([$dir]);
        $template->foo = 'bar';
        $actual = $template->fetch('zim');
        $expect = 'bar';
        $this->assertSame($expect, $actual);
    }
    
    public function testFetchDirect()
    {
        // the template file
        $file = 'root' . DIRECTORY_SEPARATOR
              . 'fetch' . DIRECTORY_SEPARATOR
              . 'zim.php';
        
        $file = Vfs::url($file);
        
        // the template code
        $code = '<?php echo $this->foo; ?>';
        
        // put it in place
        $dir = dirname($file);
        mkdir($dir, 0777, true);
        file_put_contents($file, $code);
        
        // get a template object
        $template = $this->newTemplate();
        $template->foo = 'bar';
        
        // fetch it
        $actual = $template->fetch($file);
        $expect = 'bar';
        $this->assertSame($expect, $actual);
        
        // fetch it again for coverage
        $actual = $template->fetch($file);
        $expect = 'bar';
        $this->assertSame($expect, $actual);
    }
    
    public function testPartial()
    {
        // the template file
        $file = 'root' . DIRECTORY_SEPARATOR
              . 'partial' . DIRECTORY_SEPARATOR
              . '_foo.php';
        
        $file = Vfs::url($file);
        
        // the template code
        $code = '<?php echo $this->foo; ?>';
        
        // put it in place
        $dir = dirname($file);
        mkdir($dir, 0777, true);
        file_put_contents($file, $code);
        
        // get a template object
        $template = $this->newTemplate([$dir]);
        $actual = $template->partial('_foo', ['foo' => 'dib']);
        $expect = 'dib';
        $this->assertSame($expect, $actual);
    }
    
    public function testPartialObject()
    {
        // the template file
        $templateFile = 'root' . DIRECTORY_SEPARATOR
              . 'templates' . DIRECTORY_SEPARATOR
              . 'template.php';
        $templateFile = Vfs::url($templateFile);

        $partialFile  = 'root' . DIRECTORY_SEPARATOR
              . 'templates' . DIRECTORY_SEPARATOR
              . '_many.php';
        $partialFile  = Vfs::url($partialFile);

        // the template code
        $code = '<?php
$form = $this->__raw()->form;
$data = [
    \'form\' => $form,
    \'name\' => \'Hari\'
];
echo $this->partial(\'_many\', $data);
?>';

        // put it in place
        $templateDir = dirname($templateFile);
        mkdir($templateDir, 0777, true);
        file_put_contents($templateFile, $code);
        // the partial code
        $code = '<?php
echo \'name : \' . $name . PHP_EOL;
$field = $this->form->getField(\'name\');
echo \'field : \'. $field;
?>';

        file_put_contents($partialFile, $code);
$code = '<?php
class Form
{
    public function __construct()
    {
        $this->field = new Field();
    }

    public function getField($name)
    {
        return $this->field->toArray($name);
    }
}

class Field
{
    public function toArray($name)
    {
        return $name;
    }
}
';
        $formFile = 'root' . DIRECTORY_SEPARATOR
              . 'classes' . DIRECTORY_SEPARATOR
              . 'Form.php';
        $formFile  = Vfs::url($formFile);            
        
        $dir = dirname($formFile);
        mkdir($dir, 0777, true);
        file_put_contents($formFile, $code);
        require $formFile;
        
        // get a template object
        $template = $this->newTemplate([$templateDir]);
        $form = new \Form();

        $template->addData([
            'form' => $form,
            'title' => 'Demonstration'
        ]);
        $actual = $template->fetch('template');
        $expected = 'name : Hari
field : name';
        $this->assertSame($expected, $actual);
    }
    
    public function testFindTemplateNotFound()
    {
        $template = $this->newTemplate();
        $this->setExpectedException('Aura\View\Exception\TemplateNotFound');
        $template->find('no_such_template');
    }
    
    public function testGetHelper()
    {
        $template = $this->newTemplate();
        $actual = $template->getHelper('mockHelper');
        $this->assertInstanceOf('Aura\View\Helper\MockHelper', $actual);
        $again = $template->getHelper('mockHelper');
        $this->assertSame($actual, $again);
    }
    
    public function testGetHelperNotMapped()
    {
        $template = $this->newTemplate();
        $this->setExpectedException('Aura\View\Exception\HelperNotMapped');
        $actual = $template->getHelper('noSuchHelper');
    }
    
    public function testGetHelperLocator()
    {
        $template = $this->newTemplate();
        $actual = $template->getHelperLocator();
        $this->assertInstanceOf('Aura\View\HelperLocator', $actual);
    }
    
    public function testGetTemplateFinder()
    {
        $template = $this->newTemplate();
        $actual = $template->getTemplateFinder();
        $this->assertInstanceOf('Aura\View\TemplateFinder', $actual);
    }
    
    public function test__raw()
    {
        $template = $this->newTemplate();
        $actual = $template->__raw();
        $this->assertInstanceOf('StdClass', $actual);
    }
    
    public function testGithubIssue15()
    {
        $expect = [
            [
                'id' => "1",
                'author_id' => "1",
                'title' => "Hello World",
                'body' => "Hello World",
            ],
            [
                'id' => "2",
                'author_id' => "2",
                'title' => "Sample title 2",
                'body' => "Sample body for the title 2",
            ],
            [
                'id' => "3",
                'author_id' => "3",
                'title' => "Sample title 3",
                'body' => "body 3",
            ]
        ];
        
        $template = $this->newTemplate();
        $template->posts = $expect;
        
        foreach ($template->posts as $key => $actual) {
            $this->assertSame($expect[$key]['id'], $actual['id']);
            $this->assertSame($expect[$key]['author_id'], $actual['author_id']);
            $this->assertSame($expect[$key]['title'], $actual['title']);
            $this->assertSame($expect[$key]['body'], $actual['body']);
        }
    }
}
